Install Vault:

----
$ src/test/bash/install_vault.sh
----

Start the Vault server:

----
$ src/test/bash/local_run_vault.sh
----

Vault is started listening on `0.0.0.0:8200` using the `inmem` storage.
Vault is sealed and not initialized when starting up
so you need to initialize it first.

----
$ export VAULT_ADDR="http://localhost:8200"
$ export VAULT_TLS_SKIP=true
$ vault init
----

You should see something like:

----
Key 1: 7149c6a2e16b8833f6eb1e76df03e47f6113a3288b3093faf5033d44f0e70fe701
Key 2: 901c534c7988c18c20435a85213c683bdcf0efcd82e38e2893779f152978c18c02
Key 3: 03ff3948575b1165a20c20ee7c3e6edf04f4cdbe0e82dbff5be49c63f98bc03a03
Key 4: 216ae5cc3ddaf93ceb8e1d15bb9fc3176653f5b738f5f3d1ee00cd7dccbe926e04
Key 5: b2898fc8130929d569c1677ee69dc5f3be57d7c4b494a6062693ce0b1c4d93d805
Initial Root Token: 19aefa97-cccc-bbbb-aaaa-225940e63d76

Vault initialized with 5 keys and a key threshold of 3. Please
securely distribute the above keys. When the Vault is re-sealed,
restarted, or stopped, you must provide at least 3 of these keys
to unseal it again.

Vault does not store the master key. Without at least 3 keys,
your Vault will remain permanently sealed.
----

Vault will initialize and return a set of unsealing keys and the root token.
Pick 3 keys and unseal Vault. Store the Vault token in the `VAULT_TOKEN`
 environment variable.

----
$ vault unseal (Key 1)
$ vault unseal (Key 2)
$ vault unseal (Key 3)
$ export VAULT_TOKEN=(Root token)
----

Spring Cloud Vault accesses different resources. By default, the secret
backend is enabled which accesses secret config settings via JSON endpoints.

The HTTP service has resources in the form:

----
/secret/{application}
/secret/{application},{profile}
/secret/{defaultContext}
/secret/{defaultContext},{profile}
----

where the "application" is injected as the `spring.application.name` in the
`SpringApplication` (i.e. what is normally "application" in a regular
Spring Boot app), "profile" is an active profile (or comma-separated
list of properties). Properties retrieved from Vault will be used "as-is"
without further prefixing of the property names.

== Client Side Usage

To use these features in an application, just build it as a Spring
Boot application that depends on spring-cloud-vault-config (e.g. see
the test cases). Example Maven configuration:

[source,xml,indent=0]
.pom.xml
----
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.3.3.RELEASE</version>
        <relativePath /> <!-- lookup parent from repository -->
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-vault-config</artifactId>
            <version>x.y.z</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

    <!-- repositories also needed for snapshots and milestones -->
----

Then you can create a standard Spring Boot application, like this simple HTTP server:

----
@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
----

When it runs it will pick up the external configuration from the
default local config server on port `8200` if it is running. To modify
the startup behaviour you can change the location of the Vault server
using `bootstrap.properties` (like `application.properties` but for
the bootstrap phase of an application context), e.g.

[source,yaml]
----
spring.cloud.vault:
    enabled: true
    token: vault-token
----

=== AppId authentication

Vault supports https://www.vaultproject.io/docs/auth/app-id.html[AppId]
authentication that consists of two hard to guess tokens. The AppId
defaults to `spring.application.name` that is statically configured.
The second token is the UserId which is a part determined by the application,
usually related to the runtime environment. IP address, Mac address or a
Docker container name are good examples. Spring Cloud Vault Config supports
IP address, Mac address and static UserId's (e.g. supplied via System properties).
The IP and Mac address are represented as Hex-encoded SHA256 hash.

IP address-based UserId's use the local host's IP address.

[source,yaml]
.bootstrap.yml using SHA256 IP-Address UserId's
----
spring.cloud.vault:
    enabled: true
    authentication: APPID
    app-id:
        user-id: IP_ADDRESS
----

The corresponding command to generate the IP address UserId from a command line is:

----
$ echo -n 192.168.99.1 | sha256sum
----
NOTE: Including the line break of `echo` leads to a different hash value
so make sure to include the `-n` flag.

Mac address-based UserId's obtain their network device from the
localhost-bound device. The configuration also allows specifying
a `network-interface` hint to pick the right device. The value of
`network-interface` is optional and can be either an interface
name or interface index (0-based).

[source,yaml]
.bootstrap.yml using SHA256 Mac-Address UserId's
----
spring.cloud.vault:
    enabled: true
    authentication: APPID
    app-id:
        user-id: MAC_ADDRESS
        network-interface: eth0
----

The corresponding command to generate the IP address UserId from a command line is:

----
$ echo -n 0AFEDE1234AC | sha256sum
----

NOTE: The Mac address is specified uppercase and without colons.
Including the line break of `echo` leads to a different hash value
so make sure to include the `-n` flag.
